# 并发支持技术方案

## 问题诊断

### 当前实现的错误

当前实现使用了 **per-user 锁** 策略：
```python
# session_manager.py
async def get_user_lock(self, user_id: str) -> asyncio.Lock

# employee.py / query.py
user_lock = await session_manager.get_user_lock(user_id)
async with user_lock:
    async for msg in employee_service.query(...)
```

**问题**：
1. Per-user 锁只能保证同一用户的请求串行执行
2. **不同用户的请求仍然会并发调用同一个 `ClaudeSDKClient` 实例**
3. `ClaudeSDKClient` 是单例（`KBEmployeeService` / `KBAdminService` 各一个）
4. 根据 SDK 文档，Client 是"长运行进程"，维护持久化 shell 环境，不支持并发调用

## 关键测试验证

### 测试结果

通过 `scripts/test_session_resume.py` 验证：

1. **✅ 跨 Client session 恢复**：不同 `ClaudeSDKClient` 实例可以通过 `resume` 参数共享同一个 session
2. **✅ 并发 session 恢复**：多个 Client 可以并发恢复同一个 session（无冲突）
3. **✅ session 隔离性**：不同 session 完全隔离，不会混淆

### 重要发现

**`ClaudeSDKClient` 的 `resume` 参数支持跨实例恢复会话**：
- Session 状态存储在**服务端**，而不是 Client 实例本地
- 不同 Client 可以访问同一个 session，只要使用相同的 `resume` 参数
- 并发恢复是安全的，多个 Client 同时恢复同一个 session 不会冲突

## 推荐方案：Client Pool + resume 参数

### 架构设计

```
┌─────────────────────────────────────────────────────────┐
│                   KBEmployeeService                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ClientPool (size=N)                                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                │
│  │ Client1 │  │ Client2 │  │ Client3 │  ...           │
│  │ (通用)  │  │ (通用)  │  │ (通用)  │                │
│  └─────────┘  └─────────┘  └─────────┘                │
│                                                         │
│  工作流程：                                             │
│  1. 请求到来，获取用户 session_id                      │
│  2. 从池中获取空闲 Client                              │
│  3. 使用 resume=session_id 恢复会话                    │
│  4. 处理请求                                           │
│  5. 归还 Client 到池中                                 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 核心特性

1. **池中的 Client 是通用的**，不绑定特定 session
2. **每次使用时动态配置 `resume` 参数**恢复用户 session
3. **支持真正并发**，每个请求独占一个 Client
4. **使用后归还到池中**，供其他请求使用

## 文件修改清单

### 1. 新增文件

**`backend/services/client_pool.py`** (已创建)
- `SDKClientPool` 类：客户端连接池管理
- `PoolManager` 类：单例管理器，支持多个池（Employee、Admin）

### 2. 修改文件

**`backend/services/kb_service_factory.py`**
- 移除 `_query_lock`（不再需要全局锁）
- 使用 `SDKClientPool` 替代单一 `self.client`
- 修改 `query()` 方法使用池化客户端

**`backend/api/employee.py`**
- 移除 `user_lock` 逻辑
- 直接调用 service（池化已在 service 层处理）

**`backend/api/query.py`**
- 移除 `user_lock` 逻辑
- 直接调用 service

**`backend/services/session_manager.py`**
- 移除 `get_user_lock()` 方法
- 移除 `_user_locks` 和 `_locks_lock`

**`backend/config/settings.py`**
- 添加池大小配置项：
  - `EMPLOYEE_CLIENT_POOL_SIZE` (默认 3)
  - `ADMIN_CLIENT_POOL_SIZE` (默认 2)

**`.env.example`**
- 添加池大小配置示例

## 实施步骤

### Phase 1: 基础架构 (1-2小时)

1. **创建 Client Pool 类** ✅ 已完成
   - `backend/services/client_pool.py`

2. **添加配置项**
   - 修改 `backend/config/settings.py`
   - 更新 `.env.example`

### Phase 2: 修改 KBServiceFactory (2-3小时)

3. **修改 `KBEmployeeService`**
   - 移除 `_query_lock`
   - 添加 `client_pool` 属性
   - 修改 `initialize()` 方法注册连接池
   - 修改 `query()` 方法使用 `pool.acquire(session_id)`

4. **修改 `KBAdminService`**
   - 类似 Employee Service 的修改

### Phase 3: 清理旧代码 (1小时)

5. **修改 API 层**
   - `backend/api/employee.py`：移除 `user_lock` 逻辑
   - `backend/api/query.py`：移除 `user_lock` 逻辑

6. **修改 SessionManager**
   - `backend/services/session_manager.py`：移除并发锁相关代码

### Phase 4: 测试验证 (1-2小时)

7. **创建并发测试脚本**
   - 模拟多用户并发请求
   - 验证 session 恢复正确性
   - 验证并发性能

8. **运行现有测试**
   - 确保现有功能不受影响
   - 验证向后兼容性

## 技术细节

### Client Pool 实现

```python
class SDKClientPool:
    async def acquire(self, session_id: Optional[str] = None):
        """获取客户端，可选的恢复 session"""
        client = await self.available.get()

        try:
            if session_id:
                # 恢复 session：创建新的 client
                options = self.options_factory(session_id)
                new_client = ClaudeSDKClient(options=options)
                await new_client.connect()

                yield new_client

                # 使用后断开，创建通用 client 放回池中
                await new_client.disconnect()
                generic_client = self._create_generic_client()
                await self.available.put(generic_client)
            else:
                # 新会话：直接使用通用 client
                yield client
                await self.available.put(client)
        except Exception:
            # 异常处理...
            raise
```

### Options Factory 设计

```python
def create_employee_options(session_id: Optional[str] = None) -> ClaudeAgentOptions:
    """创建 Employee Agent 的 options"""
    options = ClaudeAgentOptions(
        system_prompt={...},
        allowed_tools=[...],
        mcp_servers={...},
        permission_mode="acceptEdits",
        cwd=...,
        env=...
    )

    if session_id:
        options.resume = session_id  # 恢复会话

    return options
```

## 配置建议

### 池大小配置

```bash
# .env 配置示例
EMPLOYEE_CLIENT_POOL_SIZE=3    # 员工服务：高频查询，建议 3-5
ADMIN_CLIENT_POOL_SIZE=2       # 管理员服务：低频操作，建议 2-3
CLIENT_POOL_MAX_WAIT=30        # 获取客户端最大等待时间（秒）
```

### 资源估算

- 每个 `ClaudeSDKClient` 约占用 1GiB RAM
- 默认配置（3+2=5个 Client）约需 5GiB RAM
- 可根据服务器资源调整池大小

## 风险与缓解

### 风险 1：池大小不足
- **表现**：请求等待超时
- **缓解**：动态监控池使用率，自动扩容
- **临时方案**：返回 503 Service Unavailable

### 风险 2：Client 异常
- **表现**：Client 连接失败或异常断开
- **缓解**：健康检查机制，自动替换异常 Client
- **临时方案**：创建新的 Client 替代

### 风险 3：Session 恢复失败
- **表现**：`resume` 参数无效
- **缓解**：创建新 session，记录错误日志
- **临时方案**：降级为新会话处理

## 备选方案

### 方案 B：全局锁（简单但无并发）
```python
class KBEmployeeService:
    _global_lock = asyncio.Lock()

    async def query(self, ...):
        async with self._global_lock:
            # 所有请求串行执行
```
- 优点：实现简单，资源消耗最小
- 缺点：无法并发，高延迟

### 方案 C：每请求创建 Client（安全但低效）
```python
async def query(self, ...):
    client = ClaudeSDKClient(options=...)
    await client.connect()
    try:
        # 使用 client
    finally:
        await client.disconnect()
```
- 优点：完全隔离，无并发问题
- 缺点：初始化开销大，无法利用 session 连续性

## 验收标准

### 功能验收
- [ ] 多用户并发请求正常处理
- [ ] Session 恢复功能正常
- [ ] 不同用户 session 完全隔离
- [ ] 现有 API 接口向后兼容

### 性能验收
- [ ] 并发请求响应时间在可接受范围内
- [ ] 池大小配置生效
- [ ] 内存使用在预期范围内

### 稳定性验收
- [ ] 长时间运行无内存泄漏
- [ ] Client 异常自动恢复
- [ ] 高并发场景下稳定运行

## 下一步行动

1. **开始实施 Phase 1**：配置项和基础架构
2. **实施 Phase 2**：修改 KBServiceFactory
3. **实施 Phase 3**：清理旧代码
4. **实施 Phase 4**：测试验证

**预计总工时**：5-8小时（包含测试）

---

*最后更新：2025-12-07*
*测试验证完成：✅*
*技术方案确定：✅ Client Pool + resume 参数*
*实施状态：✅ 已完成*

## 实施完成总结

### 已完成的修改

**Phase 1: 基础架构**
- ✅ `backend/services/client_pool.py` - SDKClientPool 和 PoolManager 实现
- ✅ `backend/config/settings.py` - 添加连接池配置项
- ✅ `.env.example` - 添加连接池配置示例

**Phase 2: 修改 KBServiceFactory**
- ✅ `backend/services/kb_service_factory.py`
  - KBEmployeeService: 使用 SDKClientPool，添加 `_create_options()` 工厂方法
  - KBAdminService: 使用 SDKClientPool，添加 `_create_options()` 工厂方法
  - 添加 `get_pool_stats()` 方法获取连接池统计

**Phase 3: 清理旧代码**
- ✅ `backend/api/employee.py` - 移除 user_lock 逻辑
- ✅ `backend/api/query.py` - 移除 user_lock 逻辑
- ✅ `backend/services/session_manager.py` - 移除 `get_user_lock()` 方法和相关属性

### 配置项

```bash
# .env 配置
EMPLOYEE_CLIENT_POOL_SIZE=3    # 员工服务池大小（默认 3）
ADMIN_CLIENT_POOL_SIZE=2       # 管理员服务池大小（默认 2）
CLIENT_POOL_MAX_WAIT=30        # 获取客户端最大等待时间（秒）
```

### 资源消耗

- 每个 ClaudeSDKClient 约占用 1GiB RAM
- 默认配置（3+2=5 个 Client）约需 5GiB RAM
